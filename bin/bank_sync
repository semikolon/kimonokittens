#!/usr/bin/env ruby
# frozen_string_literal: true

require 'dotenv/load'
require 'json'
require 'fileutils'
require_relative '../lib/banking/lunchflow_client'
require_relative '../lib/persistence'
require_relative '../lib/services/apply_bank_payment'
require_relative '../lib/services/payment_aggregator'
require_relative '../lib/sms/gateway'

# Helper: Extract phone number from Swish transaction description
# @param description [String] Transaction description from Lunchflow
# @return [String, nil] E.164 phone number (+46XXXXXXXXX) or nil
def extract_phone_from_description(description)
  return nil unless description

  # Lunchflow Swish format: "from: +46XXXXXXXXX ..."
  match = description.match(/from:\s*(\+46\d{9})/)
  match ? match[1] : nil
end

# Parse command line flags
dry_run = ARGV.include?('--dry-run')

# State file for cursor tracking
STATE_DIR = 'state'
STATE_FILE = File.join(STATE_DIR, 'bank_sync.json')

# Ensure state directory exists
FileUtils.mkdir_p(STATE_DIR) unless File.exist?(STATE_DIR)

# Load last cursor from state file
state = if File.exist?(STATE_FILE)
          JSON.parse(File.read(STATE_FILE))
        else
          {}
        end
cursor = state['cursor']

# Initialize Lunch Flow client
client = LunchflowClient.new
account_id = ENV['LUNCHFLOW_ACCOUNT_ID']

unless account_id
  puts 'âŒ LUNCHFLOW_ACCOUNT_ID not set in environment'
  exit 1
end

begin
  # Fetch transactions from Lunch Flow
  response = client.fetch_transactions(account_id: account_id, since: cursor)

  if dry_run
    puts 'ğŸ” DRY RUN MODE - No changes will be saved'
    puts "Found #{response[:transactions].length} transactions:"
  end

  # Group same-day transactions by date + counterparty for aggregation
  # This enables detecting multiple small payments on same day that together meet threshold
  incoming_swish = response[:transactions].select { |tx| tx[:merchant]&.to_s&.include?('Mottagen') }

  # Group by date and counterparty (phone for Swish)
  grouped = incoming_swish.group_by do |tx|
    date = DateTime.parse(tx[:date]).to_date
    phone = extract_phone_from_description(tx[:description])
    [date, phone]
  end

  # Calculate same-day totals for each group
  same_day_totals = {}
  grouped.each do |(date, phone), txs|
    total = txs.sum { |tx| tx[:amount].abs }
    txs.each do |tx|
      same_day_totals[tx[:id]] = total
    end
  end

  # Process each transaction
  response[:transactions].each do |tx|
    if dry_run
      # Dry-run mode: print what would be done
      puts "\n#{tx[:id]}: #{tx[:amount]} #{tx[:currency]} - #{tx[:description]}"
      puts "  Booked: #{tx[:date]}"
      puts "  Counterparty: #{tx[:counterparty_name] || 'N/A'}"
      puts "  Merchant: #{tx[:merchant] || 'N/A'}"

      # Check if this would trigger reconciliation (use merchant field for Swish detection)
      if tx[:merchant]&.to_s&.include?('Mottagen')
        same_day_total = same_day_totals[tx[:id]]
        puts "  Would reconcile: YES (Swish payment, same-day total: #{same_day_total} kr)"
      else
        puts "  Would reconcile: NO"
      end
    else
      # Production mode: upsert to database
      # For Swish: extract phone from description and populate counterparty
      # For bank transfers: use counterparty name from Lunchflow
      counterparty = if tx[:merchant]&.to_s&.upcase&.include?('SWISH')
                       extract_phone_from_description(tx[:description])
                     else
                       tx[:counterparty_name]
                     end

      bank_tx = Persistence.bank_transactions.upsert(
        external_id: tx[:id],
        account_id: account_id,
        booked_at: DateTime.parse(tx[:date]),
        amount: tx[:amount],
        currency: tx[:currency],
        description: tx[:description],
        counterparty: counterparty,
        raw_json: tx
      )

      # Trigger reconciliation for INCOMING Swish payments only (rent)
      # Exclude outgoing ("Swish Skickad") which are reimbursements
      # Process ALL transactions in same-day group with aggregated total
      if tx[:merchant]&.to_s&.include?('Mottagen')
        same_day_total = same_day_totals[tx[:id]]
        ApplyBankPayment.call(
          transaction_id: bank_tx.id,
          same_day_total: same_day_total
        )
      end
    end
  end

  unless dry_run
    # Multi-day aggregation for partial payments
    # Run after same-day processing to catch partial payment combinations
    # spanning multiple days (up to 14 days, within rent-paying window day 15-27)

    # Get current month from latest transaction (or today if no transactions)
    current_month_start = if response[:transactions].any?
                            latest_date = response[:transactions].map { |tx| DateTime.parse(tx[:date]) }.max
                            Date.new(latest_date.year, latest_date.month, 1)
                          else
                            today = Date.today
                            Date.new(today.year, today.month, 1)
                          end

    # For each active tenant, find and process multi-day partial groups
    active_tenants = Persistence.tenants.find_active
    active_tenants.each do |tenant|
      groups = PaymentAggregator.find_partial_groups(tenant, current_month_start)

      groups.each do |group|
        group_total = group.sum(&:amount)

        # Process each transaction in the group with the group total
        # (similar to same-day aggregation, but for multi-day combinations)
        group.each do |tx|
          ApplyBankPayment.call(
            transaction_id: tx.id,
            same_day_total: group_total  # Reuse same parameter for multi-day
          )
        end
      end
    end
  end

  unless dry_run
    # Update cursor to latest transaction date
    if response[:transactions].any?
      latest_date = response[:transactions].map { |tx| tx[:date] }.max
      state['cursor'] = latest_date
      File.write(STATE_FILE, JSON.pretty_generate(state))
    end
  end

  # Success message
  count = response[:transactions].length
  message = if dry_run
              "Would sync #{count} transactions"
            else
              "Synced #{count} transactions"
            end
  puts message

rescue StandardError => e
  # Send admin SMS on failure (skip in dry-run)
  unless dry_run
    SmsGateway.send_admin_alert("âš ï¸ Bank sync failed: #{e.message}")
  end

  # Log error and re-raise
  puts "âŒ Error: #{e.message}"
  puts e.backtrace.first(5).join("\n") if ENV['DEBUG']
  raise
end
