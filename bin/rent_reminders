#!/usr/bin/env ruby

# Rent Reminder Scheduling Script
#
# Daily cron job that sends rent reminders based on payment status and timing.
#
# Timing:
# - Day 24, 09:45: Heads-up reminder
# - Payday, 09:45: First reminder
# - Day 27, 09:45: Urgent reminder
# - Day 28+, 09:45: Overdue (once daily)
#
# Admin alerts (payday-aware):
# - Day 26, 09:45: Info (â„¹ï¸ "PÃ¥minnelse: ...") - 24hr warning for tenants past payday
# - Day 27, 09:45: Warning (âš ï¸) - Deadline day, only tenants past their payday
# - Day 28+, 09:45: Critical (ğŸš¨ "SENT: ...") - House rent now late
#
# Payday awareness: Tenants only flagged as unpaid AFTER their payday_start_day
# (Fredrik: day 27, most others: day 25). Respects individual payment schedules.
#
# Usage:
#   bundle exec ruby bin/rent_reminders           # Live mode
#   bundle exec ruby bin/rent_reminders --dry-run # Test mode (no SMS sent)

require 'dotenv/load'
require 'time'
require_relative '../lib/persistence'
require_relative '../lib/models/rent_ledger'
require_relative '../lib/sms/gateway'
require_relative '../lib/sms/message_composer'

# Parse command line flags
dry_run = ARGV.include?('--dry-run')

if dry_run
  puts "ğŸ” DRY RUN MODE - No SMS will be sent"
  puts "=" * 60
end

# Current date/time
now = Time.now
current_month = now.strftime('%Y-%m')
current_day = now.day
current_hour = now.hour

puts "ğŸ• Running rent reminders for #{current_month} (day #{current_day}, hour #{current_hour})"

# Get admin Swish number from environment
admin_swish_number = ENV['ADMIN_SWISH_NUMBER']
unless admin_swish_number
  puts "âŒ ERROR: ADMIN_SWISH_NUMBER not set in environment"
  exit 1
end

# Get all active tenants (not opted out, not departed)
all_tenants = Persistence.tenants.all
active_tenants = all_tenants.select do |t|
  !t.sms_opt_out &&
  (!t.departure_date || t.departure_date > now.to_date)
end

puts "ğŸ‘¥ Found #{all_tenants.length} total tenants, #{active_tenants.length} active"

# Helper: Generate reference code for tenant (no dashes for iPhone copy compatibility)
def generate_reference(tenant, month)
  # KK202511Sannacmhqe9enc
  short_uuid = tenant.id[-13..-1]  # Last 13 chars of CUID
  first_name = tenant.name.split(' ').first
  month_compact = month.gsub('-', '')  # "2025-11" â†’ "202511"
  "KK#{month_compact}#{first_name}#{short_uuid}"
end

# Process each active tenant
reminders_sent = 0

active_tenants.each do |tenant|
  # Get rent ledger for current month
  ledger = Persistence.rent_ledger.find_by_tenant_and_period(
    tenant.id,
    Date.parse("#{current_month}-01")
  )

  unless ledger
    puts "  âš ï¸  #{tenant.name}: No ledger entry for #{current_month}"
    next
  end

  # Check payment status
  receipts = Persistence.rent_receipts.find_by_tenant(
    tenant.id,
    year: now.year,
    month: now.month
  )
  total_paid = receipts.sum(&:amount)
  remaining = ledger.amount_due - total_paid

  # Skip if already paid
  if remaining <= 0
    puts "  âœ… #{tenant.name}: Fully paid (#{total_paid.round} kr)"
    next
  end

  # Determine if we should send reminder and which tone
  should_send = false
  tone = nil

  # Timing logic (4 tones, all once daily)
  # No hour restrictions - cron schedule determines when reminders run
  if current_day == 24
    # Heads up reminder (day 24)
    should_send = true
    tone = :heads_up
  elsif current_day == tenant.payday_start_day
    # First payment reminder (payday)
    should_send = true
    tone = :first_reminder
  elsif current_day == 27
    # Urgent reminder (deadline day 27)
    should_send = true
    tone = :urgent
  elsif current_day >= 28
    # Overdue reminder (day 28+, once daily)
    # Rationale: Lunchflow syncs once per 24h, second reminder has no new payment data
    should_send = true
    tone = :overdue
  end

  unless should_send
    puts "  â­ï¸  #{tenant.name}: No reminder scheduled for this hour (#{remaining.round} kr remaining)"
    next
  end

  # Check idempotency: don't send same reminder twice in same day
  # (except for overdue which is sent twice daily)
  today_start = Time.new(now.year, now.month, now.day, 0, 0, 0, now.utc_offset)
  today_end = today_start + (24 * 60 * 60)

  # Query SMS events for today
  today_events = Persistence.sms_events.all.select do |event|
    event.tenant_id == tenant.id &&
    event.direction == 'out' &&
    event.created_at >= today_start &&
    event.created_at < today_end &&
    event.meta && event.meta['tone'] == tone.to_s
  end

  # Skip if already sent today (all tones now once daily)
  if today_events.any?
    puts "  ğŸ” #{tenant.name}: #{tone} reminder already sent today"
    next
  end

  # Generate reminder message (LLM hybrid approach)
  # Convert config month to rent month for SMS display
  # (ledger.period is config month, but SMS shows rent month)
  config_period = Date.parse("#{current_month}-01")
  rent_month_time = RentLedger.config_to_rent_month(config_period)
  rent_month_display = rent_month_time.strftime('%Y-%m')  # e.g., "2025-12" for December

  reference = generate_reference(tenant, current_month)
  message = MessageComposer.compose(
    tenant_name: tenant.name,
    amount: remaining,
    month: rent_month_display,  # Rent month, not config month
    recipient_phone: admin_swish_number,
    reference: reference,
    tone: tone
  )

  if dry_run
    puts "\n  ğŸ“± Would send #{tone} reminder to #{tenant.name} (#{tenant.phone_e164})"
    puts "     Amount: #{remaining.round} kr"
    puts "     Reference: #{reference}"
    puts "     Message:\n"
    message.lines.each { |line| puts "       #{line}" }
  else
    # Send SMS
    begin
      SmsGateway.send(
        to: tenant.phone_e164,
        body: message,
        meta: {
          type: 'reminder',
          tenant_id: tenant.id,
          month: current_month,
          tone: tone.to_s
        }
      )

      puts "  ğŸ“¤ Sent #{tone} reminder to #{tenant.name} at #{tenant.phone_e164} (#{remaining.round} kr remaining)"
      reminders_sent += 1
    rescue => e
      puts "  âŒ Failed to send to #{tenant.name}: #{e.message}"
    end
  end
end

puts "\nğŸ“Š Summary: #{reminders_sent} reminder(s) sent"

# Admin deadline alerts with payday awareness
# Start checking from day 26 for early warning (24hr before deadline)
# Only flag tenants as unpaid if their payday has passed
if current_day >= 26

  puts "\nğŸš¨ Checking for admin alerts..."

  unpaid_tenants = active_tenants.select do |tenant|
    ledger = Persistence.rent_ledger.find_by_tenant_and_period(
      tenant.id,
      Date.parse("#{current_month}-01")
    )
    next false unless ledger

    receipts = Persistence.rent_receipts.find_by_tenant(
      tenant.id,
      year: now.year,
      month: now.month
    )
    total_paid = receipts.sum(&:amount)
    remaining = ledger.amount_due - total_paid

    # PAYDAY-AWARE: Only flag as unpaid if their payday has passed
    payday = tenant.payday_start_day || 25  # Default to Swedish norm
    has_reached_payday = current_day >= payday

    # Only alert if unpaid AND past their payday
    remaining > 0 && has_reached_payday
  end

  if unpaid_tenants.any?
    names = unpaid_tenants.map(&:name).join(', ')

    # Urgency based on day (NO HOUR CHECKS)
    urgency, message_prefix = case current_day
    when 26
      ["â„¹ï¸", "PÃ¥minnelse: "]  # Info: 24hr warning
    when 27
      ["âš ï¸", ""]              # Warning: Deadline day
    else  # Day 28+
      ["ğŸš¨", "SENT: "]        # Critical: House rent now late
    end

    alert_message = "#{urgency} #{message_prefix}#{names} har inte betalt Ã¤n (#{current_month})"

    if dry_run
      puts "\n  ğŸ“² Would send admin alert:"
      puts "     #{alert_message}"
    else
      begin
        SmsGateway.send_admin_alert(alert_message)
        puts "  ğŸ“¤ Sent admin alert about #{unpaid_tenants.length} unpaid tenant(s)"
      rescue => e
        puts "  âŒ Failed to send admin alert: #{e.message}"
      end
    end
  else
    puts "  âœ… All tenants have paid (accounting for paydays) - no admin alert needed"
  end
end

puts "\nâœ¨ Rent reminders job complete"
